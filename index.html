<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Mini Meet — Lobby + Call</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 16px; color:#111; background:#f7f9fc; }
    header { display:flex; gap:12px; align-items:center; margin-bottom:12px; }
    .btn { padding:8px 12px; border-radius:6px; background:#2d8cff; color:white; border:none; cursor:pointer; }
    .btn.secondary { background:#e6eefc; color:#084a9a; }
    .container { display:flex; gap:18px; flex-wrap:wrap; }
    .panel { border:1px solid #e3e3e3; padding:12px; border-radius:8px; background:white; box-shadow:0 1px 2px rgba(16,24,40,0.03); }
    .lobby, .call { flex:1 1 520px; min-width:280px; }
    video { width:100%; height:auto; border-radius:6px; background:#000; }
    .participants { margin-top:8px; }
    .participant { padding:6px 8px; border-radius:6px; background:#f5f7fb; margin-bottom:6px; display:flex; justify-content:space-between; align-items:center; }
    .videos-grid { display:grid; gap:8px; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); }
    .controls { margin-top:8px; display:flex; gap:8px; align-items:center; flex-wrap:wrap }
    .small { font-size:0.9rem; color:#666; }
    .share { word-break:break-all; color:#0466d6; text-decoration:none; }
    .copy { padding:6px; border-radius:6px; background:#f1f5f9; border:1px solid #dbeafe; cursor:pointer; }
    input { box-sizing:border-box; }
  </style>
</head>
<body>
  <header>
    <h2 style="margin:0">Mini Meet</h2>
    <div style="margin-left:auto">
      <button id="homeCreate" class="btn">Create Room</button>
    </div>
  </header>

  <div id="app">
    <!-- Landing (default) -->
    <div id="landing" class="panel">
      <h3>Start or join a room</h3>
      <div style="display:flex; gap:8px; margin-top:8px;">
        <input id="roomInput" placeholder="Enter room id (or leave blank)" style="flex:1; padding:8px; border-radius:6px; border:1px solid #ddd" />
        <button id="joinBtn" class="btn secondary">Join</button>
      </div>
      <p class="small" style="margin-top:8px">Or click Create Room to make a new room and go directly into the lobby.</p>
    </div>

    <!-- Room page (lobby + call) -->
    <div id="roomPage" style="display:none;">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px">
        <div>
          <strong id="roomTitle">Room</strong>
          <div class="small" id="roomStatus">Lobby</div>
        </div>
        <div>
          <input id="nameInput" placeholder="Your name" style="padding:6px; border-radius:6px; border:1px solid #ddd" />
          <button id="leaveBtn" class="btn secondary">Leave</button>
        </div>
      </div>

      <div class="container">
        <div class="panel lobby">
          <h4>Lobby preview</h4>
          <video id="localPreview" autoplay muted playsinline></video>
          <div class="controls">
            <button id="startCallBtn" class="btn" style="display:none">Start Call</button>
            <div id="waitingText" class="small">Waiting for host to start the call...</div>
            <div style="margin-left:auto; display:flex; gap:8px; align-items:center;">
              <div class="small">Shareable link:</div>
              <a id="roomLink" class="share" href="#">—</a>
              <button id="copyLink" class="copy">Copy</button>
            </div>
          </div>
          <div style="margin-top:10px">
            <h5 style="margin:6px 0">People in lobby</h5>
            <div id="participants" class="participants"></div>
          </div>
        </div>

        <div class="panel call" id="callPanel" style="display:none;">
          <h4>Call</h4>
          <div id="videos" class="videos-grid"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();

    // page elements
    const landing = document.getElementById('landing');
    const roomPage = document.getElementById('roomPage');
    const roomTitle = document.getElementById('roomTitle');
    const roomStatus = document.getElementById('roomStatus');
    const roomLinkA = document.getElementById('roomLink');
    const copyLinkBtn = document.getElementById('copyLink');
    const participantsDiv = document.getElementById('participants');
    const localPreview = document.getElementById('localPreview');
    const startCallBtn = document.getElementById('startCallBtn');
    const waitingText = document.getElementById('waitingText');
    const callPanel = document.getElementById('callPanel');
    const videosDiv = document.getElementById('videos');
    const nameInput = document.getElementById('nameInput');
    const roomInput = document.getElementById('roomInput');
    const joinBtn = document.getElementById('joinBtn');
    const homeCreate = document.getElementById('homeCreate');
    const leaveBtn = document.getElementById('leaveBtn');

    let currentRoom = null;
    let localStream = null;
    let myId = null;
    let myName = null;
    let roomInfo = null; // latest from server
    const peers = {}; // peerId -> RTCPeerConnection
    let peerVideos = {}; // peerId -> video element (let so we can reset)
    const ICE_CONFIG = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    // landing actions
    homeCreate.onclick = async () => {
      // request the server to create a new room id, then navigate there
      try {
        homeCreate.disabled = true;
        homeCreate.textContent = 'Creating...';
        const res = await fetch('/create');
        if (!res.ok) throw new Error('Create request failed');
        const data = await res.json();
        if (data && data.room) {
          window.location.href = `/room/${encodeURIComponent(data.room)}`;
        } else {
          throw new Error('No room returned from server');
        }
      } catch (err) {
        console.error('Create room error', err);
        alert('Unable to create room. See console for details.');
      } finally {
        homeCreate.disabled = false;
        homeCreate.textContent = 'Create Room';
      }
    };

    joinBtn.onclick = () => {
      const r = (roomInput.value || '').trim();
      if (!r) {
        alert('Please enter a room id or click Create Room.');
        return;
      }
      window.location.href = `/room/${encodeURIComponent(r)}`;
    };

    // auto-detect if path is /room/:id
    function parseRoomFromPath() {
      const m = window.location.pathname.match(/^\/room\/([a-zA-Z0-9_-]+)$/);
      return m ? m[1] : null;
    }

    const initialRoom = parseRoomFromPath();
    if (initialRoom) {
      // show room UI
      landing.style.display = 'none';
      roomPage.style.display = 'block';
      enterRoom(initialRoom);
    }

    async function enterRoom(room) {
      currentRoom = room;
      roomTitle.textContent = `Room: ${room}`;
      roomLinkA.href = `${location.origin}/room/${encodeURIComponent(room)}`;
      roomLinkA.textContent = roomLinkA.href;

      // get name from localStorage or default
      const saved = localStorage.getItem('mm_name');
      nameInput.value = saved || `Guest-${Math.random().toString(36).slice(2,7)}`;

      // start local preview for lobby
      await startPreview();

      // tell server we joined the room
      myName = nameInput.value.trim();
      socket.emit('join-room', { room, name: myName });

      // update URL share link
      window.history.replaceState({}, '', `/room/${encodeURIComponent(room)}`);
    }

    // copy link
    copyLinkBtn.onclick = () => {
      navigator.clipboard.writeText(roomLinkA.href);
      copyLinkBtn.textContent = 'Copied!';
      setTimeout(() => copyLinkBtn.textContent = 'Copy', 1400);
    };

    nameInput.onchange = () => {
      localStorage.setItem('mm_name', nameInput.value.trim());
    };

    leaveBtn.onclick = () => {
      if (currentRoom) {
        socket.emit('leave-room', { room: currentRoom });
        cleanupAll();
        // navigate back to landing
        window.location.href = '/';
      }
    };

    // Start call: only visible if you're host
    startCallBtn.onclick = () => {
      if (currentRoom) {
        socket.emit('start-call', { room: currentRoom });
      }
    };

    socket.on('room-info', async (info) => {
      // initial room info
      myId = socket.id;
      roomInfo = info;
      renderLobby(info);
      // if the room has already started, immediately enter call
      if (info.started) {
        startCall(info.participants);
      }
    });

    socket.on('lobby-updated', (info) => {
      roomInfo = info;
      renderLobby(info);
    });

    socket.on('call-started', (data) => {
      roomInfo = roomInfo || {};
      roomInfo.started = true;
      startCall(data.participants);
    });

    socket.on('participant-left', ({ id }) => {
      removePeer(id);
      // update participant list if any
      if (roomInfo) {
        roomInfo.participants = (roomInfo.participants || []).filter(p => p.id !== id);
        renderLobby(roomInfo);
      }
    });

    socket.on('signal', async ({ from, data }) => {
      // handle offer / answer / candidate
      if (!peers[from] && data.type === 'offer') {
        // create pc as answerer
        await createPeerConnection(from, false);
      }
      const pc = peers[from];
      if (!pc) return;
      try {
        if (data.type === 'offer') {
          await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
          // add local tracks if not already
          addLocalTracksToPC(pc);
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          socket.emit('signal', { to: from, data: { type: 'answer', sdp: pc.localDescription }});
        } else if (data.type === 'answer') {
          await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
        } else if (data.type === 'candidate') {
          try {
            await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
          } catch (e) {
            console.warn('addIceCandidate error', e);
          }
        }
      } catch (e) {
        console.error('signal handling error', e);
      }
    });

    // create peer connection for a given peerId. initiator=true => we'll create offer later
    async function createPeerConnection(peerId, initiator) {
      if (peers[peerId]) return peers[peerId];
      const pc = new RTCPeerConnection(ICE_CONFIG);
      peers[peerId] = pc;

      pc.ontrack = (ev) => {
        attachRemoteStream(peerId, ev.streams[0]);
      };

      pc.onicecandidate = (ev) => {
        if (ev.candidate) {
          socket.emit('signal', { to: peerId, data: { type: 'candidate', candidate: ev.candidate }});
        }
      };

      pc.onconnectionstatechange = () => {
        if (pc.connectionState === 'failed' || pc.connectionState === 'closed' || pc.connectionState === 'disconnected') {
          removePeer(peerId);
        }
      };

      // add local tracks if available and we are already allowed to send
      addLocalTracksToPC(pc);

      return pc;
    }

    function addLocalTracksToPC(pc) {
      if (!localStream) return;
      const existingSenders = pc.getSenders().filter(s => s.track);
      // avoid adding duplicate tracks
      const tracksToAdd = localStream.getTracks().filter(t => !existingSenders.find(s => s.track && s.track.kind === t.kind));
      tracksToAdd.forEach(track => pc.addTrack(track, localStream));
    }

    async function startCall(participants) {
      // show call UI
      roomStatus.textContent = 'In call';
      callPanel.style.display = 'block';
      waitingText.style.display = 'none';
      startCallBtn.style.display = 'none';

      // ensure preview / local stream exists
      if (!localStream) {
        try { await startPreview(); } catch(e) { console.error(e); alert('Unable to access camera/mic.'); return; }
      }

      // participants is an ordered array from server
      const myIndex = participants.findIndex(p => p.id === socket.id);

      // create connections to each other participant with deterministic initiator rule:
      // for pair (i,j) where i<j, participant i creates the offer to j.
      for (let j = 0; j < participants.length; j++) {
        const other = participants[j];
        if (other.id === socket.id) continue;
        // ensure PC exists
        await createPeerConnection(other.id, /*initiator=*/ (myIndex < j));
      }

      // Now for any peer where myIndex < otherIndex I should create an offer
      for (let j = 0; j < participants.length; j++) {
        const other = participants[j];
        if (other.id === socket.id) continue;
        if (myIndex < j) {
          // create offer to this participant
          const pc = peers[other.id];
          try {
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            socket.emit('signal', { to: other.id, data: { type: 'offer', sdp: pc.localDescription }});
          } catch (e) {
            console.error('offer error', e);
          }
        }
      }

      // render local video in call area as well
      addLocalVideo(socket.id, nameInput.value || ('You'));
    }

    function renderLobby(info) {
      // show host-controlled UI
      const participants = info.participants || [];
      participantsDiv.innerHTML = '';
      participants.forEach(p => {
        const el = document.createElement('div');
        el.className = 'participant';
        el.innerHTML = `<div>${escapeHtml(p.name)}</div><div class="small">${p.id === info.hostId ? 'Host' : ''}</div>`;
        participantsDiv.appendChild(el);
      });

      // show Start Call button only to host and only if not started
      if (!info.started && socket.id === info.hostId) {
        startCallBtn.style.display = 'inline-block';
        waitingText.style.display = 'none';
      } else {
        startCallBtn.style.display = 'none';
        waitingText.style.display = info.started ? 'Call in progress' : 'Waiting for host to start the call...';
      }
    }

    async function startPreview() {
      if (localStream) return;
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        localPreview.srcObject = localStream;
      } catch (e) {
        console.warn('getUserMedia failed', e);
        // show placeholder (empty video element) or inform user
      }
    }

    // attach remote stream to video element
    function attachRemoteStream(peerId, stream) {
      // create or reuse video element
      let v = peerVideos[peerId];
      if (!v) {
        v = document.createElement('video');
        v.autoplay = true;
        v.playsInline = true;
        v.id = `video-${peerId}`;
        v.style.borderRadius = '6px';
        peerVideos[peerId] = v;
        videosDiv.appendChild(v);
      }
      v.srcObject = stream;
      // label? add small overlay with name if desired
    }

    function addLocalVideo(id, label) {
      // create local video element if not exists
      const localId = 'local-' + id;
      if (peerVideos[localId]) return;
      const v = document.createElement('video');
      v.autoplay = true;
      v.muted = true;
      v.playsInline = true;
      v.srcObject = localStream;
      v.style.border = '2px solid #2d8cff';
      v.style.borderRadius = '6px';
      v.id = localId;
      peerVideos[localId] = v;
      videosDiv.prepend(v); // show local first
    }

    function removePeer(peerId) {
      // close pc
      const pc = peers[peerId];
      if (pc) {
        try { pc.close(); } catch(e) {}
        delete peers[peerId];
      }
      // remove remote video
      const v = peerVideos[peerId];
      if (v && v.parentElement) {
        v.parentElement.removeChild(v);
      }
      delete peerVideos[peerId];
    }

    function cleanupAll() {
      // stop local tracks
      if (localStream) {
        localStream.getTracks().forEach(t => t.stop());
        localStream = null;
      }
      // close all peer connections
      Object.keys(peers).forEach(id => {
        try { peers[id].close(); } catch(e) {}
        delete peers[id];
      });
      // remove all videos
      videosDiv.innerHTML = '';
      peerVideos = {};
      currentRoom = null;
      roomInfo = null;
    }

    function escapeHtml(s) {
      if (!s) return '';
      return s.replace(/[&<>"']/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[c]);
    }
  </script>
</body>
</html>
